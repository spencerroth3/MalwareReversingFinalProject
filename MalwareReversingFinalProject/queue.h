#pragma once
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <limits.h>

struct Node
{
    void* value;
    struct Node* next;
    size_t valueSize;
};

struct Queue
{
    HANDLE hEvent;
    HANDLE hMutex;
    struct Node* first;
    long size;
    BOOL free;
};

struct Queue* CreateQueue(void);

//Destroy the queue and free its contents
void FreeQueue(struct Queue* queue);

//get the first value without popping
void* QueuePeekWait(struct Queue* queue, size_t* valueSize, int timeout);

#define QueuePeek(x, y) QueuePeekWait((x), (y), 0)

//get the value with popping
void* QueuePopWait(struct Queue* queue, size_t* valueSize, int timeout);

#define QueuePop(x, y) QueuePopWait((x), (y), 0)

//add a value
BOOL QueuePush(struct Queue* queue, void* value, size_t valueSize);

//is the queue empty
BOOL QueueIsEmpty(struct Queue* queue);

long QueueIndexOf(struct Queue* queue, void* value, size_t* valueSize, BOOL(*compare)(void* first, void* second));

BOOL QueueDoForAll(struct Queue* queue, BOOL (*do_func)(void* data, void* arg), void* arg);

BOOL QueueRemove(struct Queue* queue, long index, BOOL freeValue);

void* QueueGet(struct Queue* queue, long index, size_t* valueSize);

void* QueueGetIf(struct Queue* queue, BOOL (*is_wanted)(void* data, void* arg), void* arg);

void* QueuePopFifoWait(struct Queue* queue, size_t* valueSize, int timeout);

#define QueuePopFifo(x, y) QueuePopFifoWait((x), (y), 0)

BOOL QueueInsertLast(struct Queue* queue, void* value, size_t valueSize);

BOOL QueueWaitForElement(struct Queue* queue, int timeout);
