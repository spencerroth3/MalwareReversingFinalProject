#include "networking.h"

#define RC4_KEY "HELLOWORLDHELLOWORLDHELLOWORLD12"

BOOL SendData(struct Connection* conn, enum PacketType type, unsigned char* data, unsigned long datasz)
{
	//for now lets send everything as one stream, yaay tcp.
	struct MainHeader header;
	header.type = type;
	header.totalSize = datasz;
	unsigned char* buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct MainHeader) + datasz);
	if (buffer)
	{
		memcpy(buffer, &header, sizeof(struct MainHeader));
		memcpy(buffer + sizeof(struct MainHeader), data, datasz);
		if (conn->connected && datasz)
		{
			RC4(conn->key, sizeof(conn->key), ((char*)buffer + sizeof(struct MainHeader)), datasz, ((char*)buffer + sizeof(struct MainHeader)));
		}
		int result = send(conn->sockfd, buffer, sizeof(struct MainHeader) + datasz, 0);
		HeapFree(GetProcessHeap(), 0, buffer);
		return result == datasz + sizeof(struct MainHeader);
	}
	 
	return FALSE;
}

BOOL RecvData(struct Connection* conn, struct MainHeader** output)
{
	char buffer[sizeof(struct MainHeader)];
	if (recv(conn->sockfd, buffer, sizeof(struct MainHeader), MSG_PEEK | MSG_WAITALL) == sizeof(struct MainHeader))
	{
		struct MainHeader* m = (struct MainHeader*)buffer;
		struct MainHeader* recvbuf = (struct MainHeader*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct MainHeader) + m->totalSize);
		int result = recv(conn->sockfd, recvbuf, sizeof(struct MainHeader) + m->totalSize, MSG_WAITALL);
		if (result != sizeof(struct MainHeader) + m->totalSize)
		{
			*output = NULL;
			HeapFree(GetProcessHeap(), 0, recvbuf);
			return FALSE;
		}

		if (recvbuf->totalSize && conn->connected)
		{
			RC4(conn->key, sizeof(conn->key), ((char*)recvbuf + sizeof(struct MainHeader)), recvbuf->totalSize, ((char*)recvbuf + sizeof(struct MainHeader)));
		}

		*output = recvbuf;
		return TRUE;
	}

	return FALSE;
}

BOOL StartConnectionServer(SOCKET sockfd)
{
	BOOL result = FALSE;
	struct Connection* conn = (struct Connection*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Connection));
	if (conn)
	{
		conn->sockfd = sockfd;
		memcpy(conn->key, RC4_KEY, strlen(RC4_KEY));
		conn->connected = TRUE;
		result = TRUE;
		printf("Connected\n");
	}

	return result;
}

BOOL StartConnectionClient(char* ipaddr) //TODO: DNS Support?
{
	BOOL result = FALSE;
	struct Connection* conn = (struct Connection*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Connection));
	if (conn)
	{
		conn->sockfd = socket(AF_INET, SOCK_STREAM, 0);
		if (conn->sockfd != INVALID_SOCKET)
		{
			struct sockaddr_in servaddr;
			servaddr.sin_family = AF_INET;
			servaddr.sin_addr.s_addr = inet_addr(ipaddr);
			servaddr.sin_port = htons(PORT);
			if (connect(conn->sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == 0)
			{
				memcpy(conn->key, RC4_KEY, strlen(RC4_KEY));
				result = TRUE;
				conn->connected = TRUE;
				printf("Connected to %s\n", ipaddr);
				properties.currentConnection = conn;
			}
		}

		if (conn->connected)
		{
			if (conn->sockfd != INVALID_SOCKET)
			{
				closesocket(conn->sockfd);
			}
			HeapFree(GetProcessHeap(), 0, conn);
		}

	}

	return result;
}

