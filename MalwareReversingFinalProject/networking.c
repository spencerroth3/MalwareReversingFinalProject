#include "networking.h"

BOOL SendData(struct Connection* conn, enum PacketType type, unsigned char* data, unsigned long datasz)
{
	//for now lets send everything as one stream, yaay tcp.
	struct MainHeader header;
	header.type = type;
	header.totalSize = datasz;
	unsigned char* buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct MainHeader) + datasz);
	if (buffer)
	{
		memcpy(buffer, &header, sizeof(struct MainHeader));
		memcpy(buffer + sizeof(struct MainHeader), data, datasz);
		if (conn->connected && datasz)
		{
			RC4(conn->key, sizeof(conn->key), ((char*)buffer + sizeof(struct MainHeader)), datasz, ((char*)buffer + sizeof(struct MainHeader)));
		}
		int result = send(conn->sockfd, buffer, sizeof(struct MainHeader) + datasz, 0);
		HeapFree(GetProcessHeap(), 0, buffer);
		return result == datasz + sizeof(struct MainHeader);
	}
	 
	return FALSE;
}

BOOL RecvData(struct Connection* conn, struct MainHeader** output)
{
	char buffer[sizeof(struct MainHeader)];
	if (recv(conn->sockfd, buffer, sizeof(struct MainHeader), MSG_PEEK | MSG_WAITALL) == sizeof(struct MainHeader))
	{
		struct MainHeader* m = (struct MainHeader*)buffer;
		struct MainHeader* recvbuf = (struct MainHeader*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct MainHeader) + m->totalSize);
		int result = recv(conn->sockfd, recvbuf, sizeof(struct MainHeader) + m->totalSize, MSG_WAITALL);
		if (result != sizeof(struct MainHeader) + m->totalSize)
		{
			*output = NULL;
			HeapFree(GetProcessHeap(), 0, recvbuf);
			return FALSE;
		}

		if (recvbuf->totalSize && conn->connected)
		{
			RC4(conn->key, sizeof(conn->key), ((char*)recvbuf + sizeof(struct MainHeader)), recvbuf->totalSize, ((char*)recvbuf + sizeof(struct MainHeader)));
		}

		*output = recvbuf;
		return TRUE;
	}

	return FALSE;
}

BOOL StartConnectionServer(SOCKET sockfd)
{
	BOOL result = FALSE;
	struct Connection* conn = (struct Connection*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Connection));
	if (conn)
	{
		conn->sockfd = sockfd;
		struct MainHeader* header = NULL;
		if (RecvData(conn, &header))
		{
			if (header->type == PublicKey)
			{
				char* key = ((char*)header + sizeof(struct MainHeader));
				char* encrypted = NULL;
				if (GetRandomBytes(conn->key, sizeof(conn->key)))
				{
					size_t size = sizeof(struct ConnreqResponse);
					struct ConnreqResponse response;
					memcpy(response.key, conn->key, sizeof(conn->key));
					if (EncryptRSA(key, header->totalSize, &response, &size, &encrypted))
					{
						if (SendData(conn, PrivateKey, encrypted, size))
						{
							printf("Connected\n");
							conn->connected = TRUE;
							result = TRUE;
						}
					}
				}

			}
		}
	}

	return result;
}

BOOL StartConnectionClient(char* ipaddr) //TODO: DNS Support?
{
	BOOL result = FALSE;
	struct Connection* conn = (struct Connection*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Connection));
	if (conn)
	{
		//first client sends RSA Key.
		HCRYPTKEY hKey;
		if (GenerateRSAKeys(&hKey))
		{
			DWORD keysize = 0;
			if (CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &keysize))
			{
				char* keybuf = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, keysize);
				if (keybuf)
				{
					//start the socket connection
					struct sockaddr_in servaddr;
					conn->sockfd = socket(AF_INET, SOCK_TYPE, 0);
					if (conn->sockfd != INVALID_SOCKET)
					{
						servaddr.sin_family = AF_INET;
						servaddr.sin_addr.s_addr = inet_addr(ipaddr);
						servaddr.sin_port = htons(PORT);
						if (connect(conn->sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == 0)
						{

							if (SendData(conn, PublicKey, keybuf, keysize))
							{
								//TODO: fix type
								struct MainHeader* recvbuf = NULL;
								if (RecvData(conn, &recvbuf))
								{
									//get the key
									char* data = ((char*)recvbuf + sizeof(struct MainHeader));
									size_t datasz = recvbuf->totalSize;
									if (DecryptRSA(&hKey, data, &datasz))
									{
										struct ConnreqResponse* response = (struct ConnreqResponse*)data;
										memcpy(conn->key, response->key, sizeof(conn->key));
										conn->connected = TRUE;
										result = TRUE;
										printf("connected to %s\n", ipaddr);
									}
								}
							}
						}
					}
					
					HeapFree(GetProcessHeap(), 0, keybuf);
				}
			}
			CryptDestroyKey(hKey);
		}
	}

	return result;
}

