#include "queue.h"

struct Queue* CreateQueue(void)
{
    struct Queue* queue = (struct Queue*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Queue));
    if (!queue)
    {
        return NULL;
    }

    queue->hMutex = CreateMutexA(NULL, FALSE, NULL);
    if (!queue->hMutex)
    {
        HeapFree(GetProcessHeap(), 0, queue);
        return NULL;
    }

    queue->hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
    if (!queue->hEvent)
    {
        HeapFree(GetProcessHeap(), 0, queue);
        return NULL;
    }

    

    queue->first = NULL;
    queue->size = 0;
    queue->free = TRUE;
    return queue;
}

void FreeQueue(struct Queue* queue)
{
    while (!QueueIsEmpty(queue))
    {
        QueueRemove(queue, 0, queue->free);
    }
    CloseHandle(queue->hMutex);
    CloseHandle(queue->hEvent);
    HeapFree(GetProcessHeap(), 0, queue);
}

void* QueuePeekWait(struct Queue* queue, size_t* valueSize, int timeout)
{
    if (timeout != 0)
    {
        WaitForSingleObject(queue->hEvent, timeout);
    }

    WaitForSingleObject(queue->hMutex, INFINITE);
    void* ptr = queue->first ? queue->first->value : NULL;
    if (valueSize)
    {
        *valueSize = queue->first->valueSize;
    }

    ReleaseMutex(queue->hMutex);
    return ptr;
}

void* QueueGetIf(struct Queue* queue, BOOL (*is_wanted)(void* data, void* arg), void* arg)
{
    void* result = NULL;
    WaitForSingleObject(queue->hMutex, INFINITE);
    struct Node* ptr = queue->first;
    while (ptr)
    {
        if (is_wanted(ptr->value, arg))
        {
            result = ptr->value;
            break;
        }
        ptr = ptr->next;
    }
    ReleaseMutex(queue->hMutex);
    return result;
}

void* QueuePopWait(struct Queue* queue, size_t* valueSize, int timeout)
{
    if (timeout != 0)
    {
        WaitForSingleObject(queue->hEvent, timeout);
    }
    //TODO: Might be some race conditions here
    WaitForSingleObject(queue->hMutex, INFINITE);
    void* ptr = NULL;
    if (queue->first != NULL)
    {
        struct Node* first = queue->first;
        struct Node* newFirst = queue->first->next;
        queue->size = queue->size - 1;
        queue->first = newFirst;
        ptr = first->value;
        if (valueSize != NULL)
            *valueSize = first->valueSize;
        free(first);
    }

    ReleaseMutex(queue->hMutex);
    return ptr;
}

//prevent a possible race condition when adding connections by ensuring they maintain the same index.
BOOL QueueInsertLast(struct Queue* queue, void* value, size_t valueSize)
{
    BOOL result = TRUE;
    WaitForSingleObject(queue->hMutex, INFINITE);
    if (queue->size == 0)
    {
        struct Node* node = (struct Node*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Node));
        if (node)
        {
            node->value = value;
            node->next = NULL;
            node->valueSize = valueSize;
            queue->size = 1;
            queue->first = node;
        }
        else
        {
            result = FALSE;
        }
    }
    else if (queue->size != LONG_MAX)
    {
        struct Node* ptr = queue->first;
        while (ptr->next != NULL)
        {
            ptr = ptr->next;
        }

        struct Node* node = (struct Node*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (sizeof(struct Node)));
        if (node)
        {
            node->next = NULL;
            node->value = value;
            node->valueSize = valueSize;
            ptr->next = node;
            queue->size = queue->size + 1;
        }
        else
        {
            result = FALSE;
        }

    }
    else
    {
        result = FALSE;
    }

    SetEvent(queue->hEvent);
    ReleaseMutex(queue->hMutex);
    return result;
}

BOOL QueuePush(struct Queue* queue, void* value, size_t valueSize)
{
    BOOL result = TRUE;
    WaitForSingleObject(queue->hMutex, INFINITE);
    if (queue->size == 0)
    {
        struct Node* node = (struct Node*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Node));
        if (node != NULL)
        {
            node->value = value;
            node->next = NULL;
            queue->size = 1;
            queue->first = node;
            node->valueSize = valueSize;
        }
        else
        {
            result = FALSE;
        }

    }
    else if (queue->size != LONG_MAX)
    {
        struct Node* node = (struct Node*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct Node));
        if (node != NULL)
        {
            struct Node* second = queue->first;
            queue->size = queue->size + 1;
            node->next = second;
            node->value = value;
            queue->first = node;
            node->valueSize = valueSize;
        }
        else
        {
            result = FALSE;
        }

    }
    else
    {
        result = FALSE;
    }

    SetEvent(queue->hEvent);
    ReleaseMutex(queue->hMutex);
    return result;
}

BOOL QueueIsEmpty(struct Queue* queue)
{
    return QueuePeek(queue, NULL) == NULL;
}

void* QueueGet(struct Queue* queue, long index, size_t* valueSize)
{
    if (index < 0 || index >= queue->size)
        return NULL;
    void* ptr = NULL;
    WaitForSingleObject(queue->hMutex, INFINITE);
    if (index == 0)
    {
        ptr = queue->first->value;
    }
    else
    {
        struct Node* node = queue->first;
        for (int i = 0; i < index; i++)
        {
            node = node->next;
        }

        ptr = node->value;
    }

    ReleaseMutex(queue->hMutex);
    return ptr;
}

//for now, I dont need a put method - only a remove method since I will only need to add to the first index.

//NOTE: currently frees the value
BOOL QueueRemove(struct Queue* queue, long index, BOOL freeValue)
{
    if (index < 0 || index >= queue->size)
        return FALSE;
    WaitForSingleObject(queue->hMutex, INFINITE);
    struct Node* tofree = NULL;
    if (index == 0)
    {
        tofree = queue->first;
        queue->first = queue->first->next;
    }
    else
    {
        struct Node* node = queue->first;
        for (int i = 0; i < index - 1; i++)
        {
            node = node->next;
        }
        tofree = node->next;
        node->next = node->next->next;
    }
    if (freeValue)
    {
        HeapFree(GetProcessHeap(), 0, tofree->value);
    }
    HeapFree(GetProcessHeap(), 0, tofree);
    queue->size = queue->size - 1;
    ReleaseMutex(queue->hMutex);
    return TRUE;
}

long QueueIndexOf(struct Queue* queue, void* value, size_t* valueSize, BOOL(*compare)(void* first, void* second))
{
    WaitForSingleObject(queue->hMutex, INFINITE);
    long i = 0;
    struct Node* ptr = queue->first;
    while (ptr != NULL)
    {
        if (compare(ptr->value, value))
        {
            if (valueSize)
                *valueSize = ptr->valueSize;
            ReleaseMutex(queue->hMutex);
            return i;
        }
        i++;
        ptr = ptr->next;
    }
    ReleaseMutex(queue->hMutex);
    return -1;
}

BOOL QueueDoForAll(struct Queue* queue, BOOL (*do_func)(void* data, void* arg), void* arg)
{
    if (!queue || !do_func)
        return FALSE;

    WaitForSingleObject(queue->hMutex, INFINITE);
    struct Node* ptr = queue->first;
    BOOL done = TRUE;

    while (ptr != NULL)
    {
        if (!do_func(ptr->value, arg))
        {
            done = FALSE;
        }
        ptr = ptr->next;
    }

    ReleaseMutex(queue->hMutex);
    return done;

}

void* QueuePopFifoWait(struct Queue* queue, size_t* valueSize, int timeout)
{
    if (!queue)
    {
        return NULL;
    }
    if (timeout != 0)
    {
        WaitForSingleObject(queue->hEvent, timeout);
    }
    WaitForSingleObject(queue->hMutex, INFINITE);
    void* ptr = NULL;
    if (queue->first != NULL)
    {
        if (queue->first->next != NULL)
        {
            struct Node* node = queue->first;
            struct Node* prev = queue->first;
            while (node->next)
            {
                prev = node;
                node = node->next;
            }

            //make the swap
            prev->next = node->next;
            ptr = node->value;
            if (valueSize)
                *valueSize = node->valueSize;
            HeapFree(GetProcessHeap(), 0, node);
        }
        else
        {
            //only one element, just get it.
            ptr = queue->first->value;
            if (valueSize)
                *valueSize = queue->first->valueSize;
            HeapFree(GetProcessHeap(), 0, ptr);
            queue->first = NULL;
        }

        queue->size = queue->size - 1;
    }
    ReleaseMutex(queue->hMutex);
    return ptr;
}

BOOL QueueWaitForElement(struct Queue* queue, int timeout)
{
    return QueuePeekWait(queue, NULL, timeout) != NULL;
}